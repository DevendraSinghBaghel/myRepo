Mongo
=====
- document database.
- Data not predicated by joining tables  
  like in a relational database.
- This makes much easier to Shrad  or
  Share data.
- mongod - db server 
- mongo shell - connects to mongod, 
                all queries are run here
  
  creating db names and inserting values
  ------------------------------------------------
> db.names.insert({ 'name' : 'Bijith Komalan' })
WriteResult({ "nInserted" : 1 })
Querying the db
=================
> db.names.find()
{ "_id" : ObjectId("57a7ae5977d7ce796cd9c3a6"), "name" : "Bijith Komalan" }
>

-stores data as BSON Binary Json

--show DBs in mongo db
> show dbs
local  0.000GB
test   0.000GB
>

query format

db.collection , collection = table

use db , to start querying a DB

> db.movies.insertOne({'title':'Jaws','year':'1975','imdb':'tth2390'}) -> insert one record in collection movies in videos db
{
        "acknowledged" : true,
        "insertedId" : ObjectId("57a8e98b77d7ce796cd9c3a7")
}

Basic principle of querying in MongoDB
=======================================
C- Create
R - Read
U- update
D - Delete

To query collections
============================
db.movies.find(),db.movies.find().pretty(), db.movies.find({'year':'1981'}).pretty() 

var cur = db.movies.find()
cur.next()
cur.hasNext()

- mongo db document consists of field and values represented in Javascript notations 

- Every item in a Mongo database has an ID field. If it's not specified at the time the object is created, one will be assigned by Mongo. 
  This field must be unique across a specific collection, but otherwise can be any identifying string you wish to use
  if you don't want to work directly with the Mongo IDs. 

-  Just like the items within the database or documents, the query language used by Mongo relies heavily on documents to know what objects to operate on. 
    
	db.users.find({first_name:'John'})
	
   For instance, the find command here instructs Mongo to find all of the items matching the first name of John.
   It does this by passing in a simple JSON document defining first_name as John. 
   
   The pattern holds true for other MongoDB queries as well, 
   both in the shell and in the Mongo drivers. Updates, sorts and deletes all use documents to express how the operation should work with the data in the system. 
   
   db.users.remove({first_name:'John'})

   This remove command removes all items in the collection with the first name of John. 
   A documents is set, and the operation happens on the items matching that document.
   
-  The update seen here updates all of the items in the database with John as the first name and sets the value specified here. 
   Note, the update is a complete overwrite. If you had left out the address and phone, John would only have first and last names.

   db.users.update({first_name:'John'},{first_name:'John',last_name:'Mathew',addr:'142,glemorgan'} )
   
  The original update could have been done with the set operator, and this operation leaves all of the remaining fields in place. 
  It's likely that you'll use set much more often than a bare update, 
  because most changes to a database are additive and adding new fields can easily be done with this operation.
  
   db.users.update({first_name:'John'},{ $set: { last_name:'Mathew'} } )

- Mongo documents also support nested objects, objects which are deeper than a single set of keys and values.

- Sharding is a powerful scaling feature of MongoDB. Sometimes referred to as partitioning, sharding splits the database across multiple machines, storing a subset of data on each of the systems.

- Using sharding means that you can scale your application across several smaller systems rather than investing in a larger, 
  more expensive solution. While manual sharding is possible with almost any database system, 
  Mongo can handle the sharding operation so that your code can work with the database as a single system. 
  Sharding is complex to set up and maintain, but it can make it possible to manage databases at large scale without a huge capitol investment. 
  While sharding is aimed at scalability, it's arguably even more important to ensure the uptime of your system, and for this, Mongo provides replication.

-  my default connected to the test Database, just type 'db' on the mongo prompt to confirm this
- > show dbs
     admin  0.000GB
     local  0.000GB
- A DB will be created automatically once you use the use stmt
  
   > use learning_mongo
     switched to db learning_mongo
  But they will not show in the list of dbs once you insert at least one document in a collection
  
  > show dbs
	admin  0.000GB
	local  0.000GB
  > db.cars.insert({'make':'Suburau'})
	WriteResult({ "nInserted" : 1 })
  > show dbs
	admin           0.000GB
	learning_mongo  0.000GB
	local           0.000GB

- > show collections
    cars
-  > for ( i=0;i<1000;i++ ) { db.numbers.insert({"number":i}) }
     WriteResult({ "nInserted" : 1 })
   > show collections
     cars
     numbers

- > db.numbers.count()
  1000
  > db.numbers.find({"number":1})
  { "_id" : ObjectId("593a7c60e4f34c3f00c54846"), "number" : 1 }
  > db.numbers.find({"number":1}).explain
    function (verbose) {
      var explainQuery = new DBExplainQuery(this, verbose);
      return explainQuery.finish();
    }
	> db.numbers.find({"number":1}).explain()
	> db.numbers.find({"number":1}).explain('executionStats')   
	   
- db.numbers.createIndex({numbers:1}) - creates index

- mongoimport --db learning_mongo --collection tours --jsonArray --file tours.json	   ** importing data from external sources

- updating a document in mongo
   db.tours.update({"tourName":"Wine of Santa Cruz"}, {$set:{"tourRegion":"Center Coast"}})

- updating an array in the document,here the array is 'tourTags'
  > db.tours.update({"tourName":"Wine of Santa Cruz"}, {$addToSet:{"tourTags":"broadwalk"}})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

- removing a document from a collection
> db.tours.remove({"tourName":"Wine of Santa Cruz"})
WriteResult({ "nRemoved" : 1 })

- removing a collection from a db

> db.tours.drop()
true
> show collections
cars
numbers


- finding a tour with price less than or equal to  500 and duration less than or equal to 3 days 
   db.tours.find({"tourPrice":{$lte:500},"tourLength":{$lte:3}})